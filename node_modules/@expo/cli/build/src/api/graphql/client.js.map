{"version":3,"sources":["../../../../src/api/graphql/client.ts"],"sourcesContent":["import * as Log from '../../log';\nimport { fetch, type Response } from '../../utils/fetch';\nimport { getExpoApiBaseUrl } from '../endpoint';\nimport {\n  getResponseDataOrThrow,\n  UnexpectedServerData,\n  UnexpectedServerError,\n} from '../rest/client';\nimport { FetchLike } from '../rest/client.types';\nimport { wrapFetchWithOffline } from '../rest/wrapFetchWithOffline';\nimport { wrapFetchWithUserAgent } from '../rest/wrapFetchWithUserAgent';\nimport { getAccessToken, getSession } from '../user/UserSettings';\n\ntype JSONObject = Record<string, unknown>;\ntype EmptyVariables = Record<string, never>;\n\nexport type StaticDocumentNode<Result extends JSONObject, Variables extends JSONObject> = string & {\n  readonly __graphql: (vars: Variables) => Result;\n};\n\nexport function graphql<Result extends JSONObject, Variables extends JSONObject = EmptyVariables>(\n  query: string\n): StaticDocumentNode<Result, Variables> {\n  return query.trim() as StaticDocumentNode<Result, Variables>;\n}\n\nexport { UnexpectedServerError, UnexpectedServerData };\n\nexport interface QueryOptions {\n  headers?: Record<string, string>;\n}\n\nexport const query = (() => {\n  const url = getExpoApiBaseUrl() + '/graphql';\n\n  let _fetch: FetchLike | undefined;\n  const wrappedFetch: FetchLike = (...args) => {\n    if (!_fetch) {\n      _fetch = wrapFetchWithOffline(wrapFetchWithUserAgent(fetch));\n    }\n    return _fetch(...args);\n  };\n\n  const randomDelay = (attemptCount: number) =>\n    new Promise((resolve) => {\n      setTimeout(resolve, Math.min(500 + Math.random() * 1000 * attemptCount, 4_000));\n    });\n\n  const getFetchHeaders = (): Record<string, string> => {\n    const token = getAccessToken();\n    const headers: Record<string, string> = {\n      'content-type': 'application/json',\n      accept: 'application/graphql-response+json, application/graphql+json, application/json',\n    };\n    let sessionSecret: string | undefined;\n    if (token) {\n      headers.authorization = `Bearer ${token}`;\n    } else if ((sessionSecret = getSession()?.sessionSecret)) {\n      headers['expo-session'] = sessionSecret;\n    }\n    return headers;\n  };\n\n  // NOTE(@kitten): This only sorted keys one level deep since this is sufficient for most cases\n  const stringifySorted = (variables: JSONObject): string =>\n    JSON.stringify(\n      Object.keys(variables)\n        .sort()\n        .reduce((acc, key) => {\n          acc[key] = variables[key];\n          return acc;\n        }, {} as JSONObject)\n    );\n\n  let cache: Record<string, Map<string, unknown>> = {};\n  let cacheKey: string | undefined;\n\n  function resetCache() {\n    cache = {};\n  }\n\n  return async function query<Result extends JSONObject, Variables extends JSONObject>(\n    query: StaticDocumentNode<Result, Variables>,\n    variables: Variables,\n    options?: QueryOptions\n  ): Promise<Result> {\n    let isTransient = false;\n    let response: Response | undefined;\n    let data: Result | null | undefined;\n    let error: unknown;\n\n    // Pre-instantiate headers and reset the cache if they've changed\n    const headers = { ...getFetchHeaders(), ...options?.headers };\n    const headersKey = stringifySorted(headers);\n    if (!cacheKey || cacheKey !== headersKey) {\n      resetCache();\n    }\n\n    // Retrieve a cached result, if we have any via a `query => variables => Result` cache key\n    const variablesKey = stringifySorted(variables);\n    const queryCache = cache[query] || (cache[query] = new Map());\n    if (queryCache.has(variablesKey)) {\n      data = queryCache.get(variablesKey) as Result;\n    }\n\n    // Retry the query if it fails due to an unknown or transient error\n    for (let attemptCount = 0; attemptCount < 3 && !data; attemptCount++) {\n      // Add a random delay on each subsequent attempt\n      if (attemptCount > 0) {\n        await randomDelay(attemptCount);\n      }\n\n      try {\n        response = await wrappedFetch(url, {\n          ...options,\n          method: 'POST',\n          body: JSON.stringify({ query, variables }),\n          headers,\n        });\n      } catch (networkError) {\n        error = networkError || error;\n        continue;\n      }\n\n      const json = await response.json();\n      if (typeof json === 'object' && json) {\n        // If we have a transient error, we retry immediately and discard the data\n        // Otherwise, we store the first available error and get the data\n        if ('errors' in json && Array.isArray(json.errors)) {\n          isTransient = json.errors.some((e: any) => e?.extensions?.isTransient);\n          if (isTransient) {\n            data = undefined;\n            continue;\n          } else {\n            error = json.errors[0] || error;\n          }\n        }\n\n        try {\n          data = getResponseDataOrThrow<Result | null>(json);\n        } catch (dataError) {\n          // We only use the data error, if we don't have an error already\n          if (!error) {\n            error = dataError || error;\n          }\n          continue;\n        }\n      }\n    }\n\n    // Store the data in the cache, and only return a result if we have any values\n    if (data) {\n      queryCache.set(variablesKey, data);\n      const keys = Object.keys(data);\n      if (keys.length > 0 && keys.some((key) => data[key as keyof typeof data] != null)) {\n        return data;\n      }\n    }\n\n    // If we have an error, rethrow it wrapped in our custom errors\n    if (error) {\n      if (isTransient) {\n        Log.error(`We've encountered a transient error, please try again shortly.`);\n      }\n      const wrappedError = new UnexpectedServerError('' + (error as any).message);\n      wrappedError.cause = error;\n      throw wrappedError;\n    } else if (response && !response.ok) {\n      throw new UnexpectedServerError(`Unexpected server error: ${response.statusText}`);\n    } else {\n      throw new UnexpectedServerData('Unexpected server error: No returned query result');\n    }\n  };\n})();\n"],"names":["UnexpectedServerData","UnexpectedServerError","graphql","query","trim","url","getExpoApiBaseUrl","_fetch","wrappedFetch","args","wrapFetchWithOffline","wrapFetchWithUserAgent","fetch","randomDelay","attemptCount","Promise","resolve","setTimeout","Math","min","random","getFetchHeaders","getSession","token","getAccessToken","headers","accept","sessionSecret","authorization","stringifySorted","variables","JSON","stringify","Object","keys","sort","reduce","acc","key","cache","cacheKey","resetCache","options","isTransient","response","data","error","headersKey","variablesKey","queryCache","Map","has","get","method","body","networkError","json","Array","isArray","errors","some","e","extensions","undefined","getResponseDataOrThrow","dataError","set","length","Log","wrappedError","message","cause","ok","statusText"],"mappings":"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"}