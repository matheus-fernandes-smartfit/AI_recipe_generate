{"version":3,"sources":["../../../src/export/exportStaticAsync.ts"],"sourcesContent":["/**\n * Copyright Â© 2022 650 Industries.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { ExpoConfig } from '@expo/config';\nimport chalk from 'chalk';\nimport { RouteNode } from 'expo-router/build/Route';\nimport { getContextKey, stripGroupSegmentsFromPath } from 'expo-router/build/matchers';\nimport { shouldLinkExternally } from 'expo-router/build/utils/url';\nimport { type RoutesManifest } from 'expo-server/private';\nimport path from 'path';\nimport resolveFrom from 'resolve-from';\nimport { inspect } from 'util';\n\nimport { getVirtualFaviconAssetsAsync } from './favicon';\nimport { persistMetroAssetsAsync } from './persistMetroAssets';\nimport { ExportAssetMap, getFilesFromSerialAssets } from './saveAssets';\nimport { Log } from '../log';\nimport {\n  ExpoRouterRuntimeManifest,\n  MetroBundlerDevServer,\n} from '../start/server/metro/MetroBundlerDevServer';\nimport { logMetroErrorAsync } from '../start/server/metro/metroErrorInterface';\nimport { getApiRoutesForDirectory, getMiddlewareForDirectory } from '../start/server/metro/router';\nimport { assetsRequiresSort, serializeHtmlWithAssets } from '../start/server/metro/serializeHtml';\nimport { learnMore } from '../utils/link';\n\nconst debug = require('debug')('expo:export:generateStaticRoutes') as typeof console.log;\n\ntype ExtraScriptTag = {\n  platform: string;\n  src: string;\n};\n\ntype Options = {\n  mode: 'production' | 'development';\n  files?: ExportAssetMap;\n  outputDir: string;\n  minify: boolean;\n  exportServer: boolean;\n  baseUrl: string;\n  includeSourceMaps: boolean;\n  entryPoint?: string;\n  clear: boolean;\n  routerRoot: string;\n  reactCompiler: boolean;\n  maxWorkers?: number;\n  isExporting: boolean;\n  exp?: ExpoConfig;\n  // <script type=\"type/expo\" data-platform=\"ios\" src=\"...\" />\n  scriptTags?: ExtraScriptTag[];\n};\n\ntype HtmlRequestLocation = {\n  /** The output file path name to use relative to the static folder. */\n  filePath: string;\n  /** The pathname to make requests to in order to fetch the HTML. */\n  pathname: string;\n  /** The runtime route node object, used to associate async modules with the static HTML. */\n  route: RouteNode;\n};\n\nexport function injectScriptTags(html: string, scriptTags: ExtraScriptTag[]): string {\n  const scriptTagsHtml = scriptTags\n    .map((tag) =>\n      tag.platform === 'web'\n        ? `<script src=\"${tag.src}\"></script>`\n        : `<script type=\"type/expo\" src=\"${tag.src}\" data-platform=\"${tag.platform}\"></script>`\n    )\n    .join('\\n');\n  html = html.replace('</head>', `${scriptTagsHtml}\\n</head>`);\n  return html;\n}\n\n/** Match `(page)` -> `page` */\nfunction matchGroupName(name: string): string | undefined {\n  return name.match(/^\\(([^/]+?)\\)$/)?.[1];\n}\n\nexport async function getFilesToExportFromServerAsync(\n  projectRoot: string,\n  {\n    manifest,\n    serverManifest,\n    renderAsync,\n    // Servers can handle group routes automatically and therefore\n    // don't require the build-time generation of every possible group\n    // variation.\n    exportServer,\n    skipHtmlPrerendering,\n    // name : contents\n    files = new Map(),\n  }: {\n    manifest: ExpoRouterRuntimeManifest;\n    serverManifest: RoutesManifest;\n    renderAsync: (requestLocation: HtmlRequestLocation) => Promise<string>;\n    exportServer?: boolean;\n    /**\n     * Skip HTML pre-rendering when SSR is enabled (HTML will be rendered at runtime).\n     *\n     * This is separate from `exportServer` because RSC mode also uses `exportServer: true`,\n     * but still needs placeholder HTML files.\n     */\n    skipHtmlPrerendering?: boolean;\n    files?: ExportAssetMap;\n  }\n): Promise<ExportAssetMap> {\n  if (!exportServer && serverManifest) {\n    // When we're not exporting a `server` output, we provide a `_expo/.routes.json` for\n    // EAS Hosting to recognize the `headers` and `redirects` configs\n    const subsetServerManifest = {\n      headers: serverManifest.headers,\n      redirects: serverManifest.redirects,\n    };\n    files.set('_expo/.routes.json', {\n      contents: JSON.stringify(subsetServerManifest, null, 2),\n      targetDomain: 'client',\n    });\n  }\n\n  // Skip HTML pre-rendering in SSR mode since HTML will be rendered at runtime.\n  if (skipHtmlPrerendering) {\n    return files;\n  }\n\n  await Promise.all(\n    getHtmlFiles({ manifest, includeGroupVariations: !exportServer }).map(\n      async ({ route, filePath, pathname }) => {\n        // Rewrite routes should not be statically generated\n        if (route.type === 'rewrite') {\n          return;\n        }\n\n        try {\n          const targetDomain = exportServer ? 'server' : 'client';\n          files.set(filePath, { contents: '', targetDomain });\n          const data = await renderAsync({ route, filePath, pathname });\n          files.set(filePath, {\n            contents: data,\n            routeId: pathname,\n            targetDomain,\n          });\n        } catch (e: any) {\n          await logMetroErrorAsync({ error: e, projectRoot });\n          throw new Error('Failed to statically export route: ' + pathname);\n        }\n      }\n    )\n  );\n\n  return files;\n}\n\nfunction modifyRouteNodeInRuntimeManifest(\n  manifest: ExpoRouterRuntimeManifest,\n  callback: (route: RouteNode) => any\n) {\n  const iterateScreens = (screens: ExpoRouterRuntimeManifest['screens']) => {\n    Object.values(screens).map((value) => {\n      if (typeof value !== 'string') {\n        if (value._route) callback(value._route);\n        iterateScreens(value.screens);\n      }\n    });\n  };\n\n  iterateScreens(manifest.screens);\n}\n\n// TODO: Do this earlier in the process.\nfunction makeRuntimeEntryPointsAbsolute(manifest: ExpoRouterRuntimeManifest, appDir: string) {\n  modifyRouteNodeInRuntimeManifest(manifest, (route) => {\n    if (Array.isArray(route.entryPoints)) {\n      route.entryPoints = route.entryPoints.map((entryPoint) => {\n        // TODO(@hassankhan): ENG-16577\n        if (shouldLinkExternally(entryPoint)) {\n          return entryPoint;\n        }\n\n        if (entryPoint.startsWith('.')) {\n          return path.resolve(appDir, entryPoint);\n        } else if (!path.isAbsolute(entryPoint)) {\n          return resolveFrom(appDir, entryPoint);\n        }\n        return entryPoint;\n      });\n    }\n  });\n}\n\n/** Perform all fs commits */\nexport async function exportFromServerAsync(\n  projectRoot: string,\n  devServer: MetroBundlerDevServer,\n  {\n    outputDir,\n    baseUrl,\n    exportServer,\n    includeSourceMaps,\n    routerRoot,\n    files = new Map(),\n    exp,\n    scriptTags,\n  }: Options\n): Promise<ExportAssetMap> {\n  const useServerRendering = exp?.extra?.router?.unstable_useServerRendering ?? false;\n\n  const logOutput =\n    exp?.web?.output === 'server' && useServerRendering\n      ? `Server rendering is enabled. ${learnMore('https://docs.expo.dev/router/web/server-rendering/')}`\n      : `Static rendering is enabled. ${learnMore('https://docs.expo.dev/router/web/static-rendering/')}`;\n  Log.log(logOutput);\n\n  const platform = 'web';\n  const isExporting = true;\n  const isExportingWithSSR =\n    exportServer && useServerRendering && !devServer.isReactServerComponentsEnabled;\n  const appDir = path.join(projectRoot, routerRoot);\n  const injectFaviconTag = await getVirtualFaviconAssetsAsync(projectRoot, {\n    outputDir,\n    baseUrl,\n    files,\n    exp,\n  });\n\n  const [resources, { manifest, serverManifest, renderAsync, executeLoaderAsync }] =\n    await Promise.all([\n      devServer.getStaticResourcesAsync({\n        includeSourceMaps,\n      }),\n      devServer.getStaticRenderFunctionAsync(),\n    ]);\n\n  makeRuntimeEntryPointsAbsolute(manifest, appDir);\n\n  debug('Routes:\\n', inspect(manifest, { colors: true, depth: null }));\n\n  await getFilesToExportFromServerAsync(projectRoot, {\n    files,\n    manifest,\n    serverManifest,\n    exportServer,\n    skipHtmlPrerendering: isExportingWithSSR,\n    async renderAsync({ pathname, route }) {\n      const normalizedPathname =\n        pathname === '' ? '/' : pathname.startsWith('/') ? pathname : `/${pathname}`;\n\n      const useServerLoaders = exp?.extra?.router?.unstable_useServerDataLoaders;\n      let renderOpts;\n\n      if (useServerLoaders) {\n        const loaderResponse = await executeLoaderAsync(normalizedPathname, route);\n\n        if (loaderResponse !== undefined) {\n          const data = await loaderResponse.json();\n          // Transforms a `route.contextKey` into a normalized path. For example,\n          // `./nested/[id]/index.tsx` becomes `/nested/[id]/index`\n          const loaderKey = getContextKey(route.contextKey);\n          const fileSystemPath = `_expo/loaders${loaderKey}`;\n          files.set(fileSystemPath, {\n            contents: JSON.stringify(data, null, 2),\n            targetDomain: 'client',\n            loaderId: loaderKey,\n          });\n\n          renderOpts = { loader: { data, key: loaderKey } };\n        }\n      }\n\n      const template = await renderAsync(normalizedPathname, route, renderOpts);\n      let html = serializeHtmlWithAssets({\n        isExporting,\n        resources: resources.artifacts,\n        template,\n        baseUrl,\n        route,\n        hydrate: true,\n      });\n\n      if (injectFaviconTag) {\n        html = injectFaviconTag(html);\n      }\n\n      if (scriptTags) {\n        // Inject script tags into the HTML.\n        // <script type=\"type/expo\" data-platform=\"ios\" src=\"...\" />\n        html = injectScriptTags(html, scriptTags);\n      }\n\n      return html;\n    },\n  });\n\n  getFilesFromSerialAssets(resources.artifacts, {\n    platform,\n    includeSourceMaps,\n    files,\n    isServerHosted: true,\n  });\n\n  if (resources.assets) {\n    // TODO: Collect files without writing to disk.\n    // NOTE(kitten): Re. above, this is now using `files` except for iOS catalog output, which isn't used here\n    await persistMetroAssetsAsync(projectRoot, resources.assets, {\n      files,\n      platform,\n      outputDirectory: outputDir,\n      baseUrl,\n    });\n  }\n\n  if (exportServer) {\n    const apiRoutes = await exportApiRoutesAsync({\n      platform: 'web',\n      server: devServer,\n      manifest: serverManifest,\n      // NOTE(kitten): For now, we always output source maps for API route exports\n      includeSourceMaps: true,\n    });\n\n    // Add the api routes to the files to export.\n    for (const [route, contents] of apiRoutes) {\n      files.set(route, contents);\n    }\n\n    // Export SSR render module and add SSR configuration to routes manifest\n    if (isExportingWithSSR) {\n      await devServer.exportExpoRouterRenderModuleAsync({\n        files,\n        includeSourceMaps: true,\n        platform: 'web',\n      });\n\n      // Export loader bundles for routes that have loader exports\n      const useServerLoaders = exp?.extra?.router?.unstable_useServerDataLoaders;\n      if (useServerLoaders) {\n        // Get `loaderReferences` from client bundle metadata to determine which routes have loaders\n        const loaderReferences = resources.artifacts?.flatMap(\n          (artifact) => artifact.metadata?.loaderReferences ?? []\n        );\n\n        await exportLoadersAsync({\n          devServer,\n          serverManifest,\n          appDir,\n          files,\n          platform: 'web',\n          loaderReferences,\n        });\n      }\n\n      const toAssetUrl = (filename: string) =>\n        baseUrl ? `${baseUrl}/${filename}` : `/${filename}`;\n\n      const cssAssets = resources.artifacts\n        .filter((asset) => asset.type === 'css')\n        .map((asset) => toAssetUrl(asset.filename));\n\n      const jsArtifacts = resources.artifacts.filter((asset) => asset.type === 'js');\n      const orderedJsAssets = assetsRequiresSort(jsArtifacts);\n      const syncJs = orderedJsAssets.filter((asset) => !asset.metadata.isAsync);\n      const asyncJs = orderedJsAssets.filter((asset) => asset.metadata.isAsync);\n\n      const syncJsAssets = syncJs.map((asset) => toAssetUrl(asset.filename));\n\n      const htmlRoutes = getHtmlFiles({ manifest, includeGroupVariations: false });\n\n      // Build per-route async chunk assignments\n      const routeAssets = new Map<string, string[]>();\n      for (const { route } of htmlRoutes) {\n        if (!route.entryPoints || !Array.isArray(route.entryPoints)) {\n          continue;\n        }\n\n        const matchedChunks: string[] = [];\n        for (const asyncChunk of asyncJs) {\n          if (!asyncChunk.metadata.modulePaths || !Array.isArray(asyncChunk.metadata.modulePaths)) {\n            continue;\n          }\n          const hasRouteEntryPoint = route.entryPoints.some((entryPoint) =>\n            (asyncChunk.metadata.modulePaths as string[]).includes(entryPoint)\n          );\n          if (hasRouteEntryPoint) {\n            matchedChunks.push(toAssetUrl(asyncChunk.filename));\n          }\n        }\n\n        if (matchedChunks.length > 0) {\n          routeAssets.set(route.contextKey, matchedChunks);\n        }\n      }\n\n      // Add assets and rendering config to the routes manifest\n      updateExportManifestInFiles({\n        files,\n        callback: (manifest) => {\n          manifest.assets = { css: cssAssets, js: syncJsAssets };\n          manifest.rendering = {\n            mode: 'ssr',\n            file: '_expo/server/render.js',\n          };\n\n          for (const route of manifest.htmlRoutes) {\n            const asyncChunks = routeAssets.get(route.file);\n            if (asyncChunks) {\n              route.assets = { css: [], js: asyncChunks };\n            }\n          }\n        },\n      });\n    }\n  } else {\n    warnPossibleInvalidExportType(appDir);\n  }\n\n  return files;\n}\n\nexport function getHtmlFiles({\n  manifest,\n  includeGroupVariations,\n}: {\n  manifest: ExpoRouterRuntimeManifest;\n  includeGroupVariations?: boolean;\n}): HtmlRequestLocation[] {\n  const htmlFiles = new Set<Omit<HtmlRequestLocation, 'pathname'>>();\n\n  function traverseScreens(\n    screens: ExpoRouterRuntimeManifest['screens'],\n    route: RouteNode | null,\n    baseUrl = ''\n  ) {\n    for (const [key, value] of Object.entries(screens)) {\n      let leaf: string | null = null;\n      if (typeof value === 'string') {\n        leaf = value;\n      } else if (value.screens && Object.keys(value.screens).length === 0) {\n        // Ensure the trailing index is accounted for.\n        if (key === value.path + '/index') {\n          leaf = key;\n        } else {\n          leaf = value.path;\n        }\n\n        route = value._route ?? null;\n      }\n\n      if (leaf != null) {\n        let filePath = baseUrl + leaf;\n\n        if (leaf === '') {\n          filePath =\n            baseUrl === ''\n              ? 'index'\n              : baseUrl.endsWith('/')\n                ? baseUrl + 'index'\n                : baseUrl.slice(0, -1);\n        } else if (\n          // If the path is a collection of group segments leading to an index route, append `/index`.\n          stripGroupSegmentsFromPath(filePath) === ''\n        ) {\n          filePath += '/index';\n        }\n\n        // This should never happen, the type of `string | object` originally comes from React Navigation.\n        if (!route) {\n          throw new Error(\n            `Internal error: Route not found for \"${filePath}\" while collecting static export paths.`\n          );\n        }\n\n        if (includeGroupVariations) {\n          // TODO: Dedupe requests for alias routes.\n          addOptionalGroups(filePath, route);\n        } else {\n          htmlFiles.add({\n            filePath,\n            route,\n          });\n        }\n      } else if (typeof value === 'object' && value?.screens) {\n        // The __root slot has no path.\n        const newPath = value.path ? baseUrl + value.path + '/' : baseUrl;\n        traverseScreens(value.screens, value._route ?? null, newPath);\n      }\n    }\n  }\n\n  function addOptionalGroups(path: string, route: RouteNode) {\n    const variations = getPathVariations(path);\n    for (const variation of variations) {\n      htmlFiles.add({ filePath: variation, route });\n    }\n  }\n\n  traverseScreens(manifest.screens, null);\n\n  return uniqueBy(Array.from(htmlFiles), (value) => value.filePath).map((value) => {\n    const parts = value.filePath.split('/');\n    // Replace `:foo` with `[foo]` and `*foo` with `[...foo]`\n    const partsWithGroups = parts.map((part) => {\n      if (part === '*not-found') {\n        return `+not-found`;\n      } else if (part.startsWith(':')) {\n        return `[${part.slice(1)}]`;\n      } else if (part.startsWith('*')) {\n        return `[...${part.slice(1)}]`;\n      }\n      return part;\n    });\n    const filePathLocation = partsWithGroups.join('/');\n    const filePath = filePathLocation + '.html';\n    return {\n      ...value,\n      filePath,\n      pathname: filePathLocation.replace(/(\\/?index)?$/, ''),\n    };\n  });\n}\n\nfunction uniqueBy<T>(array: T[], key: (value: T) => string): T[] {\n  const seen = new Set<string>();\n  const result: T[] = [];\n  for (const value of array) {\n    const id = key(value);\n    if (!seen.has(id)) {\n      seen.add(id);\n      result.push(value);\n    }\n  }\n  return result;\n}\n\n// Given a route like `(foo)/bar/(baz)`, return all possible variations of the route.\n// e.g. `(foo)/bar/(baz)`, `(foo)/bar/baz`, `foo/bar/(baz)`, `foo/bar/baz`,\nexport function getPathVariations(routePath: string): string[] {\n  const variations = new Set<string>();\n  const segments = routePath.split('/');\n\n  function generateVariations(segments: string[], current = ''): void {\n    if (segments.length === 0) {\n      if (current) variations.add(current);\n      return;\n    }\n\n    const [head, ...rest] = segments;\n\n    if (matchGroupName(head)) {\n      const groups = head.slice(1, -1).split(',');\n\n      if (groups.length > 1) {\n        for (const group of groups) {\n          // If there are multiple groups, recurse on each group.\n          generateVariations([`(${group.trim()})`, ...rest], current);\n        }\n        return;\n      } else {\n        // Start a fork where this group is included\n        generateVariations(rest, current ? `${current}/(${groups[0]})` : `(${groups[0]})`);\n        // This code will continue and add paths without this group included`\n      }\n    } else if (current) {\n      current = `${current}/${head}`;\n    } else {\n      current = head;\n    }\n\n    generateVariations(rest, current);\n  }\n\n  generateVariations(segments);\n\n  return Array.from(variations);\n}\n\nexport async function exportApiRoutesStandaloneAsync(\n  devServer: MetroBundlerDevServer,\n  {\n    files = new Map(),\n    platform,\n    apiRoutesOnly,\n    templateHtml,\n  }: {\n    files?: ExportAssetMap;\n    platform: string;\n    apiRoutesOnly: boolean;\n    templateHtml?: string;\n  }\n) {\n  const { serverManifest, htmlManifest } = await devServer.getServerManifestAsync();\n\n  const apiRoutes = await exportApiRoutesAsync({\n    server: devServer,\n    manifest: serverManifest,\n    // NOTE(kitten): For now, we always output source maps for API route exports\n    includeSourceMaps: true,\n    platform,\n    apiRoutesOnly,\n  });\n\n  // Add the api routes to the files to export.\n  for (const [route, contents] of apiRoutes) {\n    files.set(route, contents);\n  }\n\n  if (templateHtml && devServer.isReactServerComponentsEnabled) {\n    // TODO: Export an HTML entry for each file. This is a temporary solution until we have SSR/SSG for RSC.\n    await getFilesToExportFromServerAsync(devServer.projectRoot, {\n      manifest: htmlManifest,\n      serverManifest,\n      exportServer: true,\n      files,\n      renderAsync: async ({ pathname, filePath }) => {\n        files.set(filePath, {\n          contents: templateHtml!,\n          routeId: pathname,\n          targetDomain: 'server',\n        });\n        return templateHtml!;\n      },\n    });\n  }\n\n  return files;\n}\n\nasync function exportApiRoutesAsync({\n  includeSourceMaps,\n  server,\n  platform,\n  apiRoutesOnly,\n  ...props\n}: Pick<Options, 'includeSourceMaps'> & {\n  server: MetroBundlerDevServer;\n  manifest: RoutesManifest<string>;\n  platform: string;\n  apiRoutesOnly?: boolean;\n}): Promise<ExportAssetMap> {\n  const { manifest, files } = await server.exportExpoRouterApiRoutesAsync({\n    outputDir: '_expo/functions',\n    prerenderManifest: props.manifest,\n    includeSourceMaps,\n    platform,\n  });\n\n  // HACK: Clear out the HTML and 404 routes if we're only exporting API routes. This is used for native apps that are using API routes but haven't implemented web support yet.\n  if (apiRoutesOnly) {\n    manifest.htmlRoutes = [];\n    manifest.notFoundRoutes = [];\n  }\n\n  files.set('_expo/routes.json', {\n    contents: JSON.stringify(manifest, null, 2),\n    targetDomain: 'server',\n  });\n\n  return files;\n}\n\nfunction warnPossibleInvalidExportType(appDir: string) {\n  const apiRoutes = getApiRoutesForDirectory(appDir);\n  if (apiRoutes.length) {\n    // TODO: Allow API Routes for native-only.\n    Log.warn(\n      chalk.yellow`Skipping export for API routes because \\`web.output\\` is not \"server\". You may want to remove the routes: ${apiRoutes\n        .map((v) => path.relative(appDir, v))\n        .join(', ')}`\n    );\n  }\n\n  const middlewareFile = getMiddlewareForDirectory(appDir);\n  if (middlewareFile) {\n    Log.warn(\n      chalk.yellow`Skipping export for middleware because \\`web.output\\` is not \"server\". You may want to remove ${path.relative(appDir, middlewareFile)}`\n    );\n  }\n}\n\n/**\n * Export loader bundles for routes that have loader exports and updates routes in the manifest\n * with a `loader` property.\n */\nasync function exportLoadersAsync({\n  devServer,\n  serverManifest,\n  appDir,\n  files,\n  platform,\n  loaderReferences,\n}: {\n  devServer: MetroBundlerDevServer;\n  serverManifest: RoutesManifest<string>;\n  appDir: string;\n  files: ExportAssetMap;\n  platform: string;\n  /** File paths of modules with loader exports from client bundle metadata */\n  loaderReferences: string[];\n}): Promise<void> {\n  const entryPoints: { file: string; page: string }[] = [];\n\n  for (const route of serverManifest.htmlRoutes) {\n    // Skip generated routes\n    if (route.generated) {\n      continue;\n    }\n\n    const filePath = path.isAbsolute(route.file) ? route.file : path.join(appDir, route.file);\n\n    if (loaderReferences.includes(filePath)) {\n      entryPoints.push({\n        file: filePath,\n        page: route.page,\n      });\n    }\n  }\n\n  if (entryPoints.length === 0) {\n    debug('No routes with loaders to bundle');\n    return;\n  }\n\n  const entryPointModules = entryPoints.map((e) => e.page);\n  debug('Bundling loaders for routes:', entryPointModules);\n\n  await devServer.exportExpoRouterLoadersAsync({\n    platform,\n    entryPoints,\n    files,\n    outputDir: '_expo/loaders',\n    includeSourceMaps: true,\n  });\n\n  // Update `htmlRoutes` in routes manifest for routes that have loaders\n  updateExportManifestInFiles({\n    files,\n    callback: (manifest) => {\n      const routesWithLoaders = new Set(entryPointModules);\n      for (const route of manifest.htmlRoutes) {\n        if (routesWithLoaders.has(route.page)) {\n          route.loader = `_expo/loaders${route.page}.js`;\n        }\n      }\n    },\n  });\n\n  debug('Exported loaders for routes:', entryPointModules);\n}\n\n// NOTE(@hassankhan): We should ideally persist the manifest to `files` only once instead of\n// modifying it afterwards.\nfunction updateExportManifestInFiles({\n  files,\n  callback,\n}: {\n  files: ExportAssetMap;\n  callback: (manifest: RoutesManifest<string>) => void;\n}) {\n  const routesJsonEntry = files.get('_expo/routes.json');\n  if (routesJsonEntry) {\n    const manifest = JSON.parse(routesJsonEntry.contents as string);\n    callback(manifest);\n\n    files.set('_expo/routes.json', {\n      ...routesJsonEntry,\n      contents: JSON.stringify(manifest, null, 2),\n    });\n  }\n}\n"],"names":["exportApiRoutesStandaloneAsync","exportFromServerAsync","getFilesToExportFromServerAsync","getHtmlFiles","getPathVariations","injectScriptTags","debug","require","html","scriptTags","scriptTagsHtml","map","tag","platform","src","join","replace","matchGroupName","name","match","projectRoot","manifest","serverManifest","renderAsync","exportServer","skipHtmlPrerendering","files","Map","subsetServerManifest","headers","redirects","set","contents","JSON","stringify","targetDomain","Promise","all","includeGroupVariations","route","filePath","pathname","type","data","routeId","e","logMetroErrorAsync","error","Error","modifyRouteNodeInRuntimeManifest","callback","iterateScreens","screens","Object","values","value","_route","makeRuntimeEntryPointsAbsolute","appDir","Array","isArray","entryPoints","entryPoint","shouldLinkExternally","startsWith","path","resolve","isAbsolute","resolveFrom","devServer","outputDir","baseUrl","includeSourceMaps","routerRoot","exp","useServerRendering","extra","router","unstable_useServerRendering","logOutput","web","output","learnMore","Log","log","isExporting","isExportingWithSSR","isReactServerComponentsEnabled","injectFaviconTag","getVirtualFaviconAssetsAsync","resources","executeLoaderAsync","getStaticResourcesAsync","getStaticRenderFunctionAsync","inspect","colors","depth","normalizedPathname","useServerLoaders","unstable_useServerDataLoaders","renderOpts","loaderResponse","undefined","json","loaderKey","getContextKey","contextKey","fileSystemPath","loaderId","loader","key","template","serializeHtmlWithAssets","artifacts","hydrate","getFilesFromSerialAssets","isServerHosted","assets","persistMetroAssetsAsync","outputDirectory","apiRoutes","exportApiRoutesAsync","server","exportExpoRouterRenderModuleAsync","loaderReferences","flatMap","artifact","metadata","exportLoadersAsync","toAssetUrl","filename","cssAssets","filter","asset","jsArtifacts","orderedJsAssets","assetsRequiresSort","syncJs","isAsync","asyncJs","syncJsAssets","htmlRoutes","routeAssets","matchedChunks","asyncChunk","modulePaths","hasRouteEntryPoint","some","includes","push","length","updateExportManifestInFiles","css","js","rendering","mode","file","asyncChunks","get","warnPossibleInvalidExportType","htmlFiles","Set","traverseScreens","entries","leaf","keys","endsWith","slice","stripGroupSegmentsFromPath","addOptionalGroups","add","newPath","variations","variation","uniqueBy","from","parts","split","partsWithGroups","part","filePathLocation","array","seen","result","id","has","routePath","segments","generateVariations","current","head","rest","groups","group","trim","apiRoutesOnly","templateHtml","htmlManifest","getServerManifestAsync","props","exportExpoRouterApiRoutesAsync","prerenderManifest","notFoundRoutes","getApiRoutesForDirectory","warn","chalk","yellow","v","relative","middlewareFile","getMiddlewareForDirectory","generated","page","entryPointModules","exportExpoRouterLoadersAsync","routesWithLoaders","routesJsonEntry","parse"],"mappings":"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"}