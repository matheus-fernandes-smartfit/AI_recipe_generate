{"version":3,"sources":["../../../../../src/start/server/middleware/ExpoGoManifestHandlerMiddleware.ts"],"sourcesContent":["import { ExpoUpdatesManifest } from '@expo/config';\nimport { Updates } from '@expo/config-plugins';\nimport accepts from 'accepts';\nimport crypto from 'crypto';\nimport {\n  iterableToStream,\n  streamMultipart,\n  multipartContentType,\n  FormEntry,\n  MultipartPart,\n} from 'multitars';\nimport { serializeDictionary, Dictionary } from 'structured-headers';\n\nimport { ManifestMiddleware, ManifestRequestInfo } from './ManifestMiddleware';\nimport { assertRuntimePlatform, parsePlatformHeader } from './resolvePlatform';\nimport { resolveRuntimeVersionWithExpoUpdatesAsync } from './resolveRuntimeVersionWithExpoUpdatesAsync';\nimport { ServerRequest } from './server.types';\nimport { getAnonymousIdAsync } from '../../../api/user/UserSettings';\nimport { ANONYMOUS_USERNAME } from '../../../api/user/user';\nimport {\n  CodeSigningInfo,\n  getCodeSigningInfoAsync,\n  signManifestString,\n} from '../../../utils/codesigning';\nimport { CommandError } from '../../../utils/errors';\nimport { stripPort } from '../../../utils/url';\n\nconst MULTIPART_TYPE = 'multipart/form-data';\n\nconst debug = require('debug')('expo:start:server:middleware:ExpoGoManifestHandlerMiddleware');\n\nlet multipartMixedContentType = multipartContentType;\nif (multipartMixedContentType.startsWith(MULTIPART_TYPE)) {\n  multipartMixedContentType =\n    'multipart/mixed' + multipartMixedContentType.slice(MULTIPART_TYPE.length);\n}\n\nexport enum ResponseContentType {\n  TEXT_PLAIN,\n  APPLICATION_JSON,\n  APPLICATION_EXPO_JSON,\n  MULTIPART_MIXED,\n}\n\ninterface ExpoGoManifestRequestInfo extends ManifestRequestInfo {\n  responseContentType: ResponseContentType;\n  expectSignature: string | null;\n}\n\nexport class ExpoGoManifestHandlerMiddleware extends ManifestMiddleware<ExpoGoManifestRequestInfo> {\n  public getParsedHeaders(req: ServerRequest): ExpoGoManifestRequestInfo {\n    let platform = parsePlatformHeader(req);\n\n    if (!platform) {\n      debug(\n        `No \"expo-platform\" header or \"platform\" query parameter specified. Falling back to \"ios\".`\n      );\n      platform = 'ios';\n    }\n\n    assertRuntimePlatform(platform);\n\n    // Expo Updates clients explicitly accept \"multipart/mixed\" responses while browsers implicitly\n    // accept them with \"accept: */*\". To make it easier to debug manifest responses by visiting their\n    // URLs in a browser, we denote the response as \"text/plain\" if the user agent appears not to be\n    // an Expo Updates client.\n    const accept = accepts(req);\n    const acceptedType = accept.types([\n      'unknown/unknown',\n      'multipart/mixed',\n      'application/json',\n      'application/expo+json',\n      'text/plain',\n    ]);\n\n    let responseContentType;\n    switch (acceptedType) {\n      case 'multipart/mixed':\n        responseContentType = ResponseContentType.MULTIPART_MIXED;\n        break;\n      case 'application/json':\n        responseContentType = ResponseContentType.APPLICATION_JSON;\n        break;\n      case 'application/expo+json':\n        responseContentType = ResponseContentType.APPLICATION_EXPO_JSON;\n        break;\n      default:\n        responseContentType = ResponseContentType.TEXT_PLAIN;\n        break;\n    }\n\n    const expectSignature = req.headers['expo-expect-signature'];\n\n    return {\n      responseContentType,\n      platform,\n      expectSignature: expectSignature ? String(expectSignature) : null,\n      hostname: stripPort(req.headers['host']),\n      protocol: req.headers['x-forwarded-proto'] as 'http' | 'https' | undefined,\n    };\n  }\n\n  private getDefaultResponseHeaders(): Headers {\n    const headers = new Headers();\n    // set required headers for Expo Updates manifest specification\n    headers.set('expo-protocol-version', '0');\n    headers.set('expo-sfv-version', '0');\n    headers.set('cache-control', 'private, max-age=0');\n    return headers;\n  }\n\n  public async _getManifestResponseAsync(\n    requestOptions: ExpoGoManifestRequestInfo\n  ): Promise<Response> {\n    const { exp, hostUri, expoGoConfig, bundleUrl } =\n      await this._resolveProjectSettingsAsync(requestOptions);\n\n    const runtimeVersion =\n      (await resolveRuntimeVersionWithExpoUpdatesAsync({\n        projectRoot: this.projectRoot,\n        platform: requestOptions.platform,\n      })) ??\n      // if expo-updates can't determine runtime version, fall back to calculation from config-plugin.\n      // this happens when expo-updates is installed but runtimeVersion hasn't yet been configured or when\n      // expo-updates is not installed.\n      (await Updates.getRuntimeVersionAsync(\n        this.projectRoot,\n        { ...exp, runtimeVersion: exp.runtimeVersion ?? { policy: 'sdkVersion' } },\n        requestOptions.platform\n      ));\n    if (!runtimeVersion) {\n      throw new CommandError(\n        'MANIFEST_MIDDLEWARE',\n        `Unable to determine runtime version for platform '${requestOptions.platform}'`\n      );\n    }\n\n    const codeSigningInfo = await getCodeSigningInfoAsync(\n      exp,\n      requestOptions.expectSignature,\n      this.options.privateKeyPath\n    );\n\n    const easProjectId = exp.extra?.eas?.projectId as string | undefined | null;\n    const scopeKey = await ExpoGoManifestHandlerMiddleware.getScopeKeyAsync({\n      slug: exp.slug,\n      codeSigningInfo,\n    });\n\n    const expoUpdatesManifest: ExpoUpdatesManifest = {\n      id: crypto.randomUUID(),\n      createdAt: new Date().toISOString(),\n      runtimeVersion,\n      launchAsset: {\n        key: 'bundle',\n        contentType: 'application/javascript',\n        url: bundleUrl,\n      },\n      assets: [], // assets are not used in development\n      metadata: {}, // required for the client to detect that this is an expo-updates manifest\n      extra: {\n        eas: {\n          projectId: easProjectId ?? undefined,\n        },\n        expoClient: {\n          ...exp,\n          hostUri,\n        },\n        expoGo: expoGoConfig,\n        scopeKey,\n      },\n    };\n\n    const stringifiedManifest = JSON.stringify(expoUpdatesManifest);\n\n    let manifestPartHeaders: { 'expo-signature': string } | undefined;\n    let certificateChainBody: string | null = null;\n    if (codeSigningInfo) {\n      const signature = signManifestString(stringifiedManifest, codeSigningInfo);\n      manifestPartHeaders = {\n        'expo-signature': serializeDictionary(\n          convertToDictionaryItemsRepresentation({\n            keyid: codeSigningInfo.keyId,\n            sig: signature,\n            alg: 'rsa-v1_5-sha256',\n          })\n        ),\n      };\n      certificateChainBody = codeSigningInfo.certificateChainForResponse.join('\\n');\n    }\n\n    switch (requestOptions.responseContentType) {\n      case ResponseContentType.MULTIPART_MIXED: {\n        return this.encodeFormDataAsync({\n          stringifiedManifest,\n          manifestPartHeaders,\n          certificateChainBody,\n        });\n      }\n      case ResponseContentType.APPLICATION_EXPO_JSON:\n      case ResponseContentType.APPLICATION_JSON:\n      case ResponseContentType.TEXT_PLAIN: {\n        const headers = this.getDefaultResponseHeaders();\n        headers.set(\n          'content-type',\n          ExpoGoManifestHandlerMiddleware.getContentTypeForResponseContentType(\n            requestOptions.responseContentType\n          )\n        );\n        if (manifestPartHeaders?.['expo-signature']) {\n          headers.set('expo-signature', manifestPartHeaders['expo-signature']);\n        }\n        return new Response(stringifiedManifest, { status: 200, headers });\n      }\n    }\n  }\n\n  private static getContentTypeForResponseContentType(\n    responseContentType: ResponseContentType\n  ): string {\n    switch (responseContentType) {\n      case ResponseContentType.MULTIPART_MIXED:\n        return 'multipart/mixed';\n      case ResponseContentType.APPLICATION_EXPO_JSON:\n        return 'application/expo+json';\n      case ResponseContentType.APPLICATION_JSON:\n        return 'application/json';\n      case ResponseContentType.TEXT_PLAIN:\n        return 'text/plain';\n    }\n  }\n\n  private encodeFormDataAsync({\n    stringifiedManifest,\n    manifestPartHeaders,\n    certificateChainBody,\n  }: {\n    stringifiedManifest: string;\n    manifestPartHeaders: { 'expo-signature': string } | undefined;\n    certificateChainBody: string | null;\n  }): Response {\n    const parts: FormEntry[] = [\n      [\n        'manifest',\n        new MultipartPart([stringifiedManifest], 'manifest', {\n          type: 'application/json',\n          headers: manifestPartHeaders,\n        }),\n      ],\n    ];\n    if (certificateChainBody && certificateChainBody.length > 0) {\n      parts.push([\n        'certificate_chain',\n        new MultipartPart([certificateChainBody], 'certificate_chain', {\n          type: 'application/x-pem-file',\n        }),\n      ]);\n    }\n    const headers = this.getDefaultResponseHeaders();\n    headers.set('Content-Type', multipartMixedContentType);\n    return new Response(iterableToStream(streamMultipart(parts)), { status: 200, headers });\n  }\n\n  private static async getScopeKeyAsync({\n    slug,\n    codeSigningInfo,\n  }: {\n    slug: string;\n    codeSigningInfo: CodeSigningInfo | null;\n  }): Promise<string> {\n    const scopeKeyFromCodeSigningInfo = codeSigningInfo?.scopeKey;\n    if (scopeKeyFromCodeSigningInfo) {\n      return scopeKeyFromCodeSigningInfo;\n    }\n\n    // Log.warn(\n    //   env.EXPO_OFFLINE\n    //     ? 'Using anonymous scope key in manifest for offline mode.'\n    //     : 'Using anonymous scope key in manifest.'\n    // );\n    return await getAnonymousScopeKeyAsync(slug);\n  }\n}\n\nasync function getAnonymousScopeKeyAsync(slug: string): Promise<string> {\n  const userAnonymousIdentifier = await getAnonymousIdAsync();\n  return `@${ANONYMOUS_USERNAME}/${slug}-${userAnonymousIdentifier}`;\n}\n\nfunction convertToDictionaryItemsRepresentation(obj: { [key: string]: string }): Dictionary {\n  return new Map(\n    Object.entries(obj).map(([k, v]) => {\n      return [k, [v, new Map()]];\n    })\n  );\n}\n"],"names":["ExpoGoManifestHandlerMiddleware","ResponseContentType","MULTIPART_TYPE","debug","require","multipartMixedContentType","multipartContentType","startsWith","slice","length","ManifestMiddleware","getParsedHeaders","req","platform","parsePlatformHeader","assertRuntimePlatform","accept","accepts","acceptedType","types","responseContentType","expectSignature","headers","String","hostname","stripPort","protocol","getDefaultResponseHeaders","Headers","set","_getManifestResponseAsync","requestOptions","exp","hostUri","expoGoConfig","bundleUrl","_resolveProjectSettingsAsync","runtimeVersion","resolveRuntimeVersionWithExpoUpdatesAsync","projectRoot","Updates","getRuntimeVersionAsync","policy","CommandError","codeSigningInfo","getCodeSigningInfoAsync","options","privateKeyPath","easProjectId","extra","eas","projectId","scopeKey","getScopeKeyAsync","slug","expoUpdatesManifest","id","crypto","randomUUID","createdAt","Date","toISOString","launchAsset","key","contentType","url","assets","metadata","undefined","expoClient","expoGo","stringifiedManifest","JSON","stringify","manifestPartHeaders","certificateChainBody","signature","signManifestString","serializeDictionary","convertToDictionaryItemsRepresentation","keyid","keyId","sig","alg","certificateChainForResponse","join","encodeFormDataAsync","getContentTypeForResponseContentType","Response","status","parts","MultipartPart","type","push","iterableToStream","streamMultipart","scopeKeyFromCodeSigningInfo","getAnonymousScopeKeyAsync","userAnonymousIdentifier","getAnonymousIdAsync","ANONYMOUS_USERNAME","obj","Map","Object","entries","map","k","v"],"mappings":"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"}