{"version":3,"sources":["../../../../../src/start/server/metro/runServer-fork.ts"],"sourcesContent":["// Copyright Â© 2023 650 Industries.\n// Copyright (c) Meta Platforms, Inc. and affiliates.\n//\n// Forks https://github.com/facebook/metro/blob/b80d9a0f638ee9fb82ff69cd3c8d9f4309ca1da2/packages/metro/src/index.flow.js#L57\n// and adds the ability to access the bundler instance.\nimport { createConnectMiddleware } from '@expo/metro/metro';\nimport type { RunServerOptions } from '@expo/metro/metro';\nimport MetroHmrServer, { type Client as MetroHmrClient } from '@expo/metro/metro/HmrServer';\nimport Server from '@expo/metro/metro/Server';\nimport createWebsocketServer from '@expo/metro/metro/lib/createWebsocketServer';\nimport type { ConfigT } from '@expo/metro/metro-config';\nimport assert from 'assert';\nimport http from 'http';\nimport https from 'https';\nimport type { AddressInfo } from 'net';\nimport { parse } from 'url';\nimport type { WebSocketServer } from 'ws';\n\nimport { MetroBundlerDevServer } from './MetroBundlerDevServer';\nimport { Log } from '../../../log';\nimport type { ConnectAppType } from '../middleware/server.types';\n\nexport interface SecureServerOptions {\n  readonly key: string | Buffer;\n  readonly cert: string | Buffer;\n  readonly ca: string | Buffer;\n  readonly requestCert: boolean;\n}\n\ninterface RunServerOptionsFork {\n  hasReducedPerformance?: boolean;\n  host?: string;\n  onError?($$PARAM_0$$: Error & { code?: string }): void;\n  onReady?(server: http.Server | https.Server): void;\n  onClose?(): void;\n  websocketEndpoints?: RunServerOptions['websocketEndpoints'];\n  secureServerOptions?: SecureServerOptions;\n  waitForBundler?: boolean;\n  watch?: boolean;\n}\n\nexport const runServer = async (\n  _metroBundler: MetroBundlerDevServer,\n  config: ConfigT,\n  {\n    hasReducedPerformance = false,\n    host,\n    onError,\n    onReady,\n    secureServerOptions,\n    waitForBundler = false,\n    websocketEndpoints = {},\n    watch,\n  }: RunServerOptionsFork,\n  {\n    mockServer,\n  }: {\n    // Use a mock server object instead of creating a real server, this is used in export cases where we want to reuse codepaths but not actually start a server.\n    mockServer: boolean;\n  }\n): Promise<{\n  address: AddressInfo | null;\n  server: http.Server | https.Server;\n  hmrServer: MetroHmrServer<MetroHmrClient> | null;\n  metro: Server;\n}> => {\n  // await earlyPortCheck(host, config.server.port);\n\n  // if (secure != null || secureCert != null || secureKey != null) {\n  //   // eslint-disable-next-line no-console\n  //   console.warn(\n  //     chalk.inverse.yellow.bold(' DEPRECATED '),\n  //     'The `secure`, `secureCert`, and `secureKey` options are now deprecated. ' +\n  //       'Use the `secureServerOptions` object instead to pass options to ' +\n  //       \"Metro's https development server.\",\n  //   );\n  // }\n\n  const { middleware, end, metroServer } = await createConnectMiddleware(config, {\n    hasReducedPerformance,\n    waitForBundler,\n    watch,\n  });\n\n  if (!mockServer) {\n    assert(typeof (middleware as any).use === 'function');\n  }\n  const serverApp = middleware as ConnectAppType;\n\n  let httpServer: http.Server | https.Server;\n\n  if (secureServerOptions != null) {\n    httpServer = https.createServer(secureServerOptions, serverApp);\n  } else {\n    httpServer = http.createServer(serverApp);\n  }\n\n  httpServer.on('error', (error) => {\n    if ('code' in error && error.code === 'EADDRINUSE') {\n      // If `Error: listen EADDRINUSE: address already in use :::8081` then print additional info\n      // about the process before throwing.\n      const { getRunningProcess } =\n        require('../../../utils/getRunningProcess') as typeof import('../../../utils/getRunningProcess');\n      getRunningProcess(config.server.port).then((info) => {\n        if (info) {\n          Log.error(\n            `Port ${config.server.port} is busy running ${info.command} in: ${info.directory}`\n          );\n        }\n      });\n    }\n\n    if (onError) {\n      onError(error);\n    }\n    end();\n  });\n\n  // Disable any kind of automatic timeout behavior for incoming\n  // requests in case it takes the packager more than the default\n  // timeout of 120 seconds to respond to a request.\n  httpServer.timeout = 0;\n\n  // Extend the close method to ensure all websocket servers are closed, and connections are terminated\n  const originalClose = httpServer.close.bind(httpServer);\n\n  httpServer.close = function closeHttpServer(callback) {\n    originalClose((err?: Error) => {\n      // Always call end() to clean up Metro workers, even if the server wasn't started.\n      // The 'close' event doesn't fire for servers that were never started (mockServer case),\n      // so we need to call end() explicitly here.\n      end();\n      callback?.(err);\n    });\n\n    // Close all websocket servers, including possible client connections (see: https://github.com/websockets/ws/issues/2137#issuecomment-1507469375)\n    for (const endpoint of Object.values(websocketEndpoints) as WebSocketServer[]) {\n      endpoint.close();\n      endpoint.clients.forEach((client) => client.terminate());\n    }\n\n    // Forcibly close active connections\n    this.closeAllConnections();\n    return this;\n  };\n\n  if (mockServer) {\n    return { address: null, server: httpServer, hmrServer: null, metro: metroServer };\n  }\n\n  return new Promise((resolve, reject) => {\n    httpServer.on('error', (error) => {\n      reject(error);\n    });\n\n    httpServer.listen(config.server.port, host, () => {\n      if (onReady) {\n        onReady(httpServer);\n      }\n\n      const hmrServer = new MetroHmrServer(\n        metroServer.getBundler(),\n        metroServer.getCreateModuleId(),\n        config\n      );\n\n      Object.assign(websocketEndpoints, {\n        '/hot': createWebsocketServer({\n          websocketServer: hmrServer,\n        }),\n      });\n\n      httpServer.on('upgrade', (request, socket, head) => {\n        const { pathname } = parse(request.url!);\n        if (pathname != null && websocketEndpoints[pathname]) {\n          websocketEndpoints[pathname].handleUpgrade(request, socket, head, (ws) => {\n            websocketEndpoints[pathname].emit('connection', ws, request);\n          });\n        } else {\n          socket.destroy();\n        }\n      });\n\n      const address = httpServer.address();\n\n      resolve({\n        address: address && typeof address === 'object' ? address : null,\n        server: httpServer,\n        hmrServer,\n        metro: metroServer,\n      });\n    });\n  });\n};\n"],"names":["runServer","_metroBundler","config","hasReducedPerformance","host","onError","onReady","secureServerOptions","waitForBundler","websocketEndpoints","watch","mockServer","middleware","end","metroServer","createConnectMiddleware","assert","use","serverApp","httpServer","https","createServer","http","on","error","code","getRunningProcess","require","server","port","then","info","Log","command","directory","timeout","originalClose","close","bind","closeHttpServer","callback","err","endpoint","Object","values","clients","forEach","client","terminate","closeAllConnections","address","hmrServer","metro","Promise","resolve","reject","listen","MetroHmrServer","getBundler","getCreateModuleId","assign","createWebsocketServer","websocketServer","request","socket","head","pathname","parse","url","handleUpgrade","ws","emit","destroy"],"mappings":"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"}